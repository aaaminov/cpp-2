### Билет 1: Базовые конструкции

### (a) Алфавит языка. Ключевые слова. Идентификаторы. Литералы. Знаки операций.

**Алфавит языка C++** Любая программа на языке C++ состоит из следующих символов:

- Цифры (0, 1, ..., 9)
- Буквы латинского алфавита (a, b, ..., z, A, ..., Z)
- Нижнее подчеркивание (_)
- Пробельные символы и перенос строки
- Скобки ({} , () , [] , <>)
- Кавычки и апострофы (" , ’)

**Ключевые слова** Слова, имеющие особое значение, называются ключевыми словами. Некоторые из них: alignas, alignof, and, and_eq, asm, auto, bitand, bitor, bool, break, case, catch, char, char8_t, char16_t, char32_t, class, compl, concept, const, consteval, constexpr, constinit, const_cast, continue, co_await, co_return, co_yield, decltype, default, delete, do.

**Идентификаторы** Идентификатор — имя программного объекта. Правила для идентификаторов:

1. Не начинается с цифры.
2. Не содержит пробелов.
3. Не является ключевым словом.
4. Чувствительно к регистру (Alice и alice — разные идентификаторы).

Примеры:

```cpp
alla //OK
allo4ka //OK
allochka -ivanova //CE (character ’-’ cannot be in identifier)
allo4ka_ivanova //OK
allochka ivanova //CE (must not contain whitespace characters)
2dima //CE (must not start with a number)
_ //OK
_2dima //OK
asm //CE (key word)
AsM //OK
```

**Константы/литералы** Константы или литералы — это значения, встроенные в текст программы.

- Целочисленные константы: десятичные (123), восьмеричные (045), шестнадцатеричные (0x1A, 0XBD), двоичные (0b101, 0B1001).
- Символьные константы: ’a’, ’n’.
- Вещественные константы: 3.14, .24e10.
- Строковые литералы: "a", "c", "n", "This is string".
- Логические константы: true, false.
- Нулевой указатель: nullptr.

**Знаки операций** Знаки операций характеризуются арностью, приоритетом и ассоциативностью:

- Арность — количество аргументов.
- Приоритет — порядок вычисления операций.
- Ассоциативность — порядок выполнения операций с одинаковым приоритетом.

Примеры:

```cpp
10 / 3; // Integer division - 3
-10 / 3.; //Real division - 3.3333
-5; //Unary operation
5 - 3; // Binary operation
```

### (b) Структура программы на C++. Объявления и определения. Операторы. Комментарии.

**Структура программы на C++** Код программы на C++ организован в функции и модули. Пример простейшей программы:

```cpp
#include <iostream>

int main() {
    std::cout << "Hello, world!";
    return 0;
}
```

**Объявления и определения**

- **Объявление (declaration)** сообщает компилятору о существовании переменной, функции или типа.
- **Определение (definition)** это место, где объект или функция получает свои значения или тело.

```cpp
extern int x; // Объявление
int x = 10;   // Определение
```

**Операторы**

- **Арифметические**: +, -, *, /, %.
- **Логические**: &&, ||, !.
- **Побитовые**: &, |, ^, ~, <<, >>.
- **Сравнения**: ==, !=, <, >, <=, >=.
- **Присваивания**: =, +=, -=, *=, /=, %=, &=, |=, ^=, <<=, >>=.
- **Прочие**: sizeof, typeid, new, delete, &, *, ++, --.

**Комментарии** В C++ есть два типа комментариев:

- Однострочные комментарии: `//`
- Многострочные комментарии: `/* */`

Пример:

```cpp
// This is a single-line comment
/* This is a
   multi-line comment */
```

### (c) Концепция типа данных. Фундаментальные типы данных: целые типы, символьный тип, логический тип, типы с плавающей точкой, void. Операции над фундаментальными типами.

**Концепция типа данных** Тип данных определяет множество значений, которые могут быть приняты переменной, а также операции, которые могут быть над этими значениями выполнены.

**Фундаментальные типы данных**

- **Целые типы**: int, short, long, long long.

  - Модификаторы: signed, unsigned.

  - Примеры:

    ```cpp
    int x = 5;
    unsigned int y = 10U;
    ```

- **Символьный тип**: char, char_t, char16_t, char32_t.

  - Пример:

    ```cpp
    char c = 'A';
    ```

- **Логический тип**: bool.

  - Примеры:

    ```cpp
    bool flag = true;
    ```

- **Типы с плавающей точкой**: float, double, long double.

  - Примеры:

    ```cpp
    float f = 3.14f;
    double d = 3.14;
    ```

- **Пустой тип**: void.

  - Используется для указания на отсутствие значения.

  - Пример:

    ```cpp
    void function();
    ```

**Операции над фундаментальными типами**

- **Арифметические операции**: +, -, *, /, %.

  - Примеры:

    ```cpp
    int sum = 5 + 3; // 8
    double div = 10.0 / 3.0; // 3.3333
    ```

- **Логические операции**: &&, ||, !.

  - Примеры:

    ```cpp
    bool result = (5 > 3) && (10 < 20); // true
    ```

- **Побитовые операции**: &, |, ^, ~, <<, >>.

  - Примеры:

    ```cpp
    int bitwiseAnd = 5 & 3; // 1
    ```

### (d) Переменные. Классы памяти и области действия. Область видимости. Инициализация. CV-квалификаторы.

**Переменные** Переменная — именованная область памяти. Примеры объявления и инициализации переменных:

```cpp
int x;
short y = 1;
float z(1.5);
char t{'@'};
```

**Классы памяти и области действия**

- **Автоматическая область действия**: локальные переменные внутри функции.
- **Глобальная область действия**: переменные вне всех функций.
- **Статическая область действия**: переменные, которые сохраняют свое значение между вызовами функций.

**Область видимости (scope)** Область видимости определяет, где переменная доступна. Примеры:

```cpp
int globalVar;

void func() {
    int localVar;
    {
        int nestedVar;
    }
    // nestedVar не доступен здесь
}
```

**Инициализация** Инициализация — присваивание начального значения переменной. Способы инициализации:

- Прямая:

  ```cpp
  int x = 5;
  ```

- Через список инициализации:

  ```cpp
  int x{5};
  ```

**CV-квалификаторы**

- **const**: квалификатор для константных переменных, значение которых нельзя изменить.
- **volatile**: квалификатор для переменных, которые могут быть изменены в любой момент времени.

Пример:

```cpp
const int constantVar = 10;
volatile int volatileVar = 20;
```

### (e) Выражения. Особенности работы операций. Категории значения. static_cast, sizeof.

**Выражения** Последовательность операций и операндов, которая вычисляет значение.

```cpp
int result = 5 + 3 * 2; // result = 11
```

**Особенности работы операций**

- Приоритет операций определяет порядок их выполнения.
- Ассоциативность операций определяет порядок выполнения операций с одинаковым приоритетом.

**Категории значения**

- **lvalue** (left value): объект, имеющий адрес.
- **rvalue** (right value): временное значение, не имеющее адреса.

Пример:

```cpp
int x = 10;
int &ref = x; // ref - lvalue, x - lvalue
int &&rref =

 5; // rref - rvalue
```

**static_cast** Используется для явного приведения типов.

```cpp
int a = 10;
double b = static_cast<double>(a); // b = 10.0
```

**sizeof** Возвращает размер объекта или типа в байтах.

```cpp
int size = sizeof(int); // обычно 4
```

### Билет 2: Операторы управления

### (a) Условная операция (?:). Условный оператор (if − else).

**Условная операция (?:)** Тернарный оператор возвращает значение на основе условия.

```cpp
int x = 10;
int y = (x > 5) ? 1 : 0; // y = 1
```

**Условный оператор (if − else)** Позволяет выполнять код в зависимости от условия.

```cpp
int x = 10;
if (x > 5) {
    std::cout << "x больше 5";
} else {
    std::cout << "x меньше или равно 5";
}
```

### (b) Циклы: while, do − while, for.

**Цикл while** Повторяет блок кода, пока условие истинно.

```cpp
int i = 0;
while (i < 5) {
    std::cout << i << " ";
    ++i;
}
```

**Цикл do-while** Выполняет блок кода хотя бы один раз, а затем повторяет, пока условие истинно.

```cpp
int i = 0;
do {
    std::cout << i << " ";
    ++i;
} while (i < 5);
```

**Цикл for** Повторяет блок кода заданное количество раз.

```cpp
for (int i = 0; i < 5; ++i) {
    std::cout << i << " ";
}
```

### (c) Оператор switch.

Позволяет выполнять блоки кода в зависимости от значения выражения.

```cpp
int x = 2;
switch (x) {
    case 1:
        std::cout << "One";
        break;
    case 2:
        std::cout << "Two";
        break;
    default:
        std::cout << "Other";
}
```

### (d) Операторы break и continue. Оператор безусловного перехода.

**Оператор break** Прерывает выполнение цикла или оператора switch.

```cpp
for (int i = 0; i < 10; ++i) {
    if (i == 5) break;
    std::cout << i << " ";
}
```

**Оператор continue** Пропускает оставшуюся часть текущей итерации цикла и переходит к следующей итерации.

```cpp
for (int i = 0; i < 10; ++i) {
    if (i % 2 == 0) continue;
    std::cout << i << " ";
}
```

**Оператор goto** Позволяет передавать управление в произвольное место в программе.

```cpp
int i = 0;
start:
    std::cout << i << " ";
    ++i;
    if (i < 5) goto start;
```

### 3. Массивы и указатели

### (a) Операция взятия адреса. Указатели. Разыменовывание указателя. Арифметика указателей. Константные указатели и указатели на константы. Нулевой указатель. Провисший указатель.

**Операция взятия адреса**

Операцию взятия адреса (`&`) можно применять только к lvalue значениям. Возможность взятия адреса можно использовать в качестве критерия lvalue:

```cpp
int x;
std::cout << &x << '\\\\n'; // displayed in hexadecimal

// it is possible
&x, &(x = 8), &(++x);

// that’s not possible
&5, &(x + 8), &(x++);
```

**Указатели**

Указатель — это тип данных, позволяющий хранить адрес другого объекта в памяти. Пусть T — некоторый тип, тогда T* — указатель на T.

```cpp
int* px; // pointer to int
float* py; // pointer to float
long long* pll; // pointer to long long
const char** ppc; // pointer to pointer to const char
double*** pppd; // pointer to pointer to pointer to double
```

Примеры:

```cpp
int x = 0;
const float y = 0;

int* px = &x;
int* px2 = &(++x); // == px

const float* cpy = &y;
const int* cpx = &x;

int** ppx = &px;
const int** cppx = &cpx;

float* py = &y; // Ошибка: py нарушает const свойства y
```

**Разыменовывание указателя**

Операция разыменования (`*`) используется для получения значения объекта по указателю:

```cpp
int x = 1;
float y = 2.5;

int* px = &x;
float* py = &y;

*px = 11;
*py = 3.5;
std::cout << *px << ' ' << *py; // 11 3.5
std::cout << x << ' ' << y; // 11 3.5
```

**Арифметика указателей**

Арифметика указателей включает операции сложения и вычитания с целыми числами, а также вычитания указателей одного типа:

```cpp
int x, y, z;
std::cout << &z - &x << '\\\\n'; // most likely 2

int32_t* p = ...;
p + 5; // + 20 bytes
p - 4; // - 16 bytes
p += 10;
p -= 12;
++p;
p--;
```

**Константные указатели и указатели на константы**

Указатель на константу:

```cpp
const int* px; // or int const*
```

Константный указатель:

```cpp
int* const px = &x;
```

Комбинирование константности:

```cpp
const int* const px = &x; // constant pointer to constant int
```

**Нулевой указатель**

Нулевой указатель не указывает на какой-либо объект и инициализируется как `nullptr`:

```cpp
int* p = nullptr;
const float* pp = nullptr;
```

**Провисший указатель**

Провисший указатель (dangling pointer) возникает, когда указатель указывает на освобожденную память:

```cpp
int* p = nullptr;
{
    int x = 0;
    p = &x;
}
// x выходит из области видимости
return *p; // провисший указатель, ошибка!
```

### (b) Ссылки. Правила работы со ссылками. Ссылки на константу.

**Ссылки**

Ссылка — это альтернативное имя для существующей переменной:

```cpp
int x = 10;
int& ref = x;
ref = 20;
std::cout << x; // 20
```

**Ссылки на константу**

Ссылки на константу не позволяют изменять объект, на который они ссылаются:

```cpp
const int& cref = x;
std::cout << cref; // допустимо
cref = 30; // ошибка
```

### (c) Массивы в стиле C. Операции над массивами. Инициализация массивов. Связь массивов и указателей. Указатель на массив. Многомерные массивы.

**Инициализация массивов**

```cpp
int a[10];
int b[20]{};
int c[5]{1, 2, 3};
int d[]{1, 2, 3}; // размер вычисляется автоматически
```

**Связь массивов и указателей**

Массивы автоматически преобразуются в указатель на первый элемент:

```cpp
int array[10];
int* p = array;
std::cout << array; // выводит адрес первого элемента
std::cout << array + 5; // адрес пятого элемента
```

Указатели можно использовать как массивы:

```cpp
int* p = array;
std::cout << p[2]; // второй элемент массива

p += 5;
std::cout << p[2]; // седьмой элемент массива
```

**Многомерные массивы**

Массивы могут иметь несколько размерностей:

```cpp
int a[10]; // одномерный массив
a[1]; // доступ к элементу

int b[5][20]; // двумерный массив
b[3][11]; // доступ к элементу

int c[7][9][3]; // трехмерный массив
c[3][8][0]; // доступ к элементу
```

Инициализация многомерных массивов:

```cpp
int a[2][3]{1, 2, 3, 4}; // построчная инициализация
// 1 2 3
// 4 0 0

int b[][2]{1, 2, 3, 4}; // первая размерность может быть определена автоматически
// 1 2
// 3 4

int c[3][2]{{1, 2}, {3, 4}, {5, 6}};
// 1 2
// 3 4
// 5 6
```

### (d) Динамическая память. Выражения new и delete. Динамические массивы.

**Динамическая память**

Использование операторов `new` и `delete` для работы с динамической памятью:

```cpp
int* array = new int[10];
// ... использование массива
delete[] array;
```

Примеры:

```cpp
int* p = new int;
// ...
delete p; // освобождение памяти

// ошибки
int* p1 = new int;
p1 = nullptr; // утечка памяти, указатель потерян
int* p2 = new int[10];
delete p2; // ошибка, должен быть delete[]
```

### (e) Строковые литералы. Строки в стиле C. Функции для работы со строками (<cstring>).

**Строки в стиле C**

Строки в стиле C представляют собой массивы символов, заканчивающиеся нулевым символом `\\\\0`:

```cpp
char str[] = "Hello, World!";
```

Функции для работы со строками из `<cstring>`:

```cpp
#include <cstring>

char src[] = "Hello";
char dest[10];
strcpy(dest, src);
std::cout << dest; // Hello
```

### 4. Функции

### (a) Функции. Объявление и определение. Возвращаемое значение, аргументы, аргументы по умолчанию.

**Объявление и определение функций**

```cpp
int add(int a, int b); // объявление
int add(int a, int b) { // определение
    return a + b;
}
```

**Аргументы по умолчанию**

```cpp
int add(int a, int b = 5) {
    return a + b;
}
std::cout << add(10); // 15
```

### (b) Перегрузка функций. Статические переменные функции.

**Перегрузка функций**

Перегрузка позволяет иметь несколько функций с одним именем, но разными параметрами:

```cpp
int add(int a, int b) {
    return a + b;
}
double add(double a, double b) {
    return a + b;
}
```

**Статические переменные функции**

Статические переменные сохраняют свое значение между вызовами функции:

```cpp
void counter() {
    static int count = 0;
    count++;
    std::cout << count;
}
```

### (c) Передача и возврат указателей, ссылок и массивов в/из функции.

**Передача указателей, ссылок и массивов**

```cpp
void modify(int* ptr) {
    *ptr = 10;
}
int main() {
    int x = 5;
    modify(&x);
    std::cout << x; // 10
}
```

- *Возврат

указателей и ссылок**

```cpp
int* createArray(int size) {
    return new int[size];
}
void freeArray(int* array) {
    delete[] array;
}
```

### (d) Рекурсия: прямая, косвенная. Примеры рекурсивных вычислений.

**Прямая рекурсия**

Функция вызывает саму себя:

```cpp
int factorial(int n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}
```

**Косвенная рекурсия**

Функции вызывают друг друга:

```cpp
void functionA();
void functionB();

void functionA() {
    functionB();
}

void functionB() {
    functionA();
}
```

Эти примеры и описания обеспечивают основное понимание работы с массивами, указателями, ссылками, динамической памятью и функциями в языке C++.

### 5. Пользовательские типы

### (a) Перечисления (enum)

**Общее представление**

Перечисление — пользовательский тип данных, значения которого ограничены набором именованных констант некоторого целого типа. Пример:

```cpp
enum Season { kWinter, kSpring, kSummer, kFall };

Season cur_season = kFall; // auto cur_season = kFall;
Season seasons[3] = {kSpring, kFall, kWinter};
Season* ptr = &cur_season; // auto ptr = &cur_season;
Season& ref = cur_season; // auto& ref = cur_season;
```

**Правила работы**

- Низлежащие значения можно указать явно:

  ```cpp
  enum Season { kWinter = 10, kSpring, kSummer = -1, kFall };
  // kWinter == 10, kSpring == 11, kSummer == -1, kFall == 0
  ```

- Низлежащий тип тоже можно указать самостоятельно:

  ```cpp
  enum Season : int16_t { kWinter, kSpring, kSummer, kFall };
  ```

- После определения перечисления можно сразу создать переменные:

  ```cpp
  enum Season { kWinter, kSpring, kSummer, kFall} a, *ptr, arr[10];
  ```

**Анонимные перечисления**

При объявлении перечисления можно не указывать его имени:

```cpp
enum { kZero, kOne, kThree = 3, kFour, kFive };
```

Такие перечисления использовались для создания именованных констант:

```cpp
enum { kEnumValue = 11 };
const int kConstValue = 11;
&kConstValue; // valid: kConstValue - variable
&kEnumValue // invalid: kEnumValue - just a value
```

**enum class (C++11)**

Рекомендованным способом объявления перечислений является enum class:

```cpp
enum class Season { kWinter, kSpring, kSummer, kFall };
```

- К значениям enum class можно обратиться только по полному имени:

  ```cpp
  auto x = Season::kWinter;
  ```

### (b) Объединения (union)

**Общие представления**

Объединение — пользовательский тип данных, который в каждый момент времени позволяет хранить объект одного из заранее указанных типов в общей области памяти. Пример:

```cpp
union IntDouble {
  int i;
  double d;
};
```

**Правила работы**

- Размер объединений равен наибольшему из размеров своих членов:

  ```cpp
  sizeof(IntDouble) == max(sizeof(int), sizeof(double));
  ```

- Обратиться к членам объединения можно с помощью операции `.`:

  ```cpp
  IntDouble x;
  x.i = 0; // current member - i
  x.d = 1.5; // and now d
  ```

- Адреса его членов равны (C++14):

  ```cpp
  IntDouble x;
  static_cast<void*>(&x.i) == static_cast<void*>(&x.d);
  ```

- Действующий член — член объединения, к которому в последний раз была применена операция записи:

  ```cpp
  IntDouble x;
  x.i = 0; // current member - i
  std::cout << x.d; // UB
  ```

- Анонимные объединения позволяют объявить переменные с разделяемой областью памяти:

  ```cpp
  union { int x; bool y; }; // variables x and y are in the same memory area
  x = 1;
  y = false;
  ```

- Объединения могут иметь статические члены, работающие так же, как и статические члены структур.

### (c) Структуры (struct)

**Общее представление**

Структура — составной тип данных, который инкапсулирует набор данных (возможно разных типов) в одном объекте. Примеры:

```cpp
struct Complex {
  double re; // real part
  double im; // imaginary part
};

struct Array {
  int* buffer;
  size_t size;
};
```

**Правила работы**

- Поля структуры можно инициализировать при объявлении:

  ```cpp
  Complex c = {1.0, 2.0};
  Array arr = {nullptr, 0};
  ```

- Доступ к полям структуры осуществляется с помощью операции `.`:

  ```cpp
  c.re = 3.0;
  arr.buffer = new int[10];
  ```

- Размер структуры определяется с учетом выравнивания:

  ```cpp
  struct alignas(8) AlignedStruct {
    char a;
    int b;
  };
  ```

**Статические поля**

Статические поля существуют в единственном экземпляре для всех объектов структуры:

```cpp
struct Example {
  static int count;
  Example() { ++count; }
};

int Example::count = 0;
```

**Размер структуры. Выравнивание**

Размер структуры зависит от выравнивания ее полей:

```cpp
struct Packed {
  char a;
  int b;
} __attribute__((packed)); // GCC-specific

struct Default {
  char a;
  int b;
};
```

### 6. Шаблоны

### (a) Шаблоны функций. Шаблоны классов. Шаблоны переменных. Шаблоны псевдонимов типов (using).

**Шаблоны функций**

Шаблоны позволяют создавать функции, работающие с различными типами данных:

```cpp
template <typename T>
T max(T a, T b) {
  return (a > b) ? a : b;
}
```

Использование:

```cpp
int a = 5, b = 10;
std::cout << max(a, b); // 10

double x = 5.5, y = 3.3;
std::cout << max(x, y); // 5.5
```

**Шаблоны классов**

Шаблоны классов позволяют создавать классы, работающие с различными типами данных:

```cpp
template <typename T>
class Array {
  T* data;
  size_t size;
public:
  Array(size_t size) : size(size) {
    data = new T[size];
  }
  ~Array() {
    delete[] data;
  }
  T& operator[](size_t index) {
    return data[index];
  }
};
```

Использование:

```cpp
Array<int> intArray(10);
intArray[0] = 5;

Array<double> doubleArray(20);
doubleArray[0] = 3.14;
```

**Шаблоны переменных**

Пример шаблонной переменной:

```cpp
template <typename T>
constexpr T pi = T(3.1415926535897932385);
```

Использование:

```cpp
double myPi = pi<double>;
float myPiF = pi<float>;
```

**Шаблоны псевдонимов типов (using)**

Пример шаблона псевдонима:

```cpp
template <typename T>
using Vec = std::vector<T>;
```

Использование:

```cpp
Vec<int> intVec;
Vec<double> doubleVec;
```

### (b) Вывод типа аргумента шаблона. Параметры шаблона по умолчанию. Перегрузка шаблонов функций. Объявление auto переменных.

**Вывод типа аргумента шаблона**

Компилятор может автоматически выводить тип аргумента шаблона:

```cpp
template <typename T>
void print(T value) {
  std::cout << value << std::endl;
}
```

Использование:

```cpp
print(5); // T deduced as int
print(3.14); // T deduced as double
```

**Параметры шаблона по умолчанию**

Шаблоны могут иметь параметры по умолчанию:

```cpp
template <typename T = int>
void print(T value = T()) {
  std::cout << value << std::endl;
}
```

Использование:

```cpp
print(); // выводит 0
print(3.14); // выводит 3.14
```

**Перегрузка шаблонов функций**

Шаблоны функций могут быть перегружены:

```cpp
template <typename T>
void func(T a) {
  std::cout << a << std::endl;
}

void func(int a) {
  std::cout << "int: " << a << std::endl;
}
```

Использование:

```cpp
func(5); // int: 5
func(3.14); // 3.14
```

**Объявление auto переменных**

Использование `auto` для автоматического вывода типа переменной:

```cpp
auto a = 5; // int
auto b = 3.14; // double
```

### (c) Специализация шаблонов. Инстанцирование шаблонов.

**Специализация шаблонов**

Специализация позволяет определять реализации шаблонов для конкретных типов:

```cpp
template <typename T>
T abs(T x) {
  return x > 0 ? x

 : -x;
}

template <>
Complex abs(Complex x) {
  return {sqrt(x.re * x.re + x.im * x.im), 0};
}
```

Использование:

```cpp
int a = -5;
std::cout << abs(a); // 5

Complex c{3, 4};
std::cout << abs(c).re; // 5
```

**Инстанцирование шаблонов**

Компилятор создает конкретные экземпляры шаблонов на основе использования:

```cpp
template class Array<int>; // Инстанцирование шаблона для int
template class Array<double>; // Инстанцирование шаблона для double
```

### 7. Классы. Начало

### (a) Парадигмы программирования. Объектно-ориентированное программирование. Абстракция, инкапсуляция, полиморфизм, наследование.

**Парадигмы программирования**

- **Императивное программирование:** описание последовательности инструкций, ветвлений, безусловных переходов.
- **Структурное программирование:** использование независимых логически законченных процедур/функций.
- **Объектно-ориентированное программирование:** представление программы в виде совокупности классов, объектов и их взаимодействий.

**Принципы ООП**

- **Абстракция:** выделение наиболее важных свойств объектов реального мира и их оформление в виде атрибутов класса.
- **Инкапсуляция:** объединение данных и методов для работы с ними в рамках одного объекта с возможным сокрытием деталей реализации.
- **Полиморфизм:** возможность использования различных реализаций в рамках одного интерфейса.
- **Наследование:** создание нового типа данных на основе уже существующего с полным или частичным заимствованием функционала【32:3†source】【32:4†source】【32:5†source】.

### (b) Классы и объекты. Поля и методы. Модификаторы доступа. Друзья класса.

**Класс** — это описание некоторого концепта из предметной области в виде набора полей и методов для работы с ними.

```cpp
struct Stack {
    inline static const size_t kMaxSize = 100;
    size_t size = 0;
    int buffer[kMaxSize];

    // метод добавления элемента
    void Push(int value) {
        if (size < kMaxSize) {
            buffer[size++] = value;
        }
    }

    // метод удаления элемента
    void Pop() {
        if (size > 0) {
            --size;
        }
    }

    // метод получения верхнего элемента
    int Top() {
        if (size > 0) {
            return buffer[size - 1];
        }
        return -1; // или другая ошибка
    }

    // метод очистки стека
    void Clear() {
        size = 0;
    }
};
```

**Модификаторы доступа**

- **public:** доступ открыт для всех.
- **protected:** доступен для самого класса и его наследников.
- **private:** доступен только для самого класса.

**Друзья класса** — функции или классы, которые имеют доступ к закрытым членам другого класса.

```cpp
class MyClass {
    friend void FriendFunction(MyClass &obj);

private:
    int secret = 42;
};

void FriendFunction(MyClass &obj) {
    std::cout << obj.secret;
}
```

### (c) Константные и статические поля и методы. Логическая и физическая константность. Ключевое слово `mutable`.

**Константные поля и методы**

```cpp
class MyClass {
public:
    int GetValue() const {
        return value;
    }

private:
    int value = 0;
};
```

**Статические поля и методы**

```cpp
class MyClass {
public:
    static int GetStaticValue() {
        return static_value;
    }

private:
    static int static_value;
};

int MyClass::static_value = 42;
```

**Логическая и физическая константность**

- **Логическая константность:** метод помечен как `const`, но изменяет логическое состояние объекта.
- **Физическая константность:** метод не изменяет физическое состояние объекта.

Пример: для отладки объект логирует информацию о действиях над собой (считает число вызовов метода). С физической точки зрения объект не константа (обновляется счетчик), с логической - константа (пользователь не наблюдает этих изменений).

**Ключевое слово `mutable`**

Чтобы сообщить компилятору, что изменение данного поля не влияет на логическую константность объекта, его можно пометить ключевым словом mutable . mutable поля можно изменять в константных методах.

```cpp
class MyClass {
public:
    void Change() const {
        ++mutable_value;
    }

private:
    mutable int mutable_value = 0;
};
```

### 8. Конструкторы и деструктор

### (a) Агрегатная инициализация. Конструктор. Виды конструкторов. Списки инициализации. Делегирующие конструкторы. Ключевое слово `explicit`.

**Агрегатная инициализация**

```cpp
struct Point {
    int x, y;
};

Point p = {1, 2};
```

**Конструкторы**

В C++ существует несколько типов конструкторов, каждый из которых служит своей специфической цели. Вот основные типы конструкторов:

### 1. Конструктор по умолчанию (Default Constructor)
Конструктор по умолчанию не принимает аргументов и создается автоматически, если в классе не определен ни один другой конструктор. Он инициализирует объекты класса стандартным образом.

```cpp
class MyClass {
public:
    MyClass() { // Конструктор по умолчанию
        std::cout << "Конструктор по умолчанию вызван\n";
    }
};
```

### 2. Параметризованный конструктор (Parameterized Constructor)
Этот конструктор принимает один или несколько аргументов, позволяя инициализировать объекты класса с определенными значениями.

```cpp
class MyClass {
public:
    int value;
    
    MyClass(int v) : value(v) { // Параметризованный конструктор
        std::cout << "Параметризованный конструктор вызван\n";
    }
};
```

### 3. Конструктор копирования (Copy Constructor)
Конструктор копирования создает новый объект как копию существующего объекта. Он используется при передаче объекта по значению и возврате объекта из функции.

```cpp
class MyClass {
public:
    int value;
    
    MyClass(int v) : value(v) {}
    
    MyClass(const MyClass &other) : value(other.value) { // Конструктор копирования
        std::cout << "Конструктор копирования вызван\n";
    }
};
```

### 4. Перемещающий конструктор (Move Constructor)
Перемещающий конструктор используется для переноса ресурсов из одного объекта в другой, что предотвращает дорогостоящие операции копирования. Перемещающий конструктор принимает rvalue-ссылку.

```cpp
class MyClass {
public:
    int* data;
    
    MyClass(int size) : data(new int[size]) {}
    
    MyClass(MyClass &&other) noexcept : data(other.data) { // Перемещающий конструктор
        other.data = nullptr;
        std::cout << "Перемещающий конструктор вызван\n";
    }
    
    ~MyClass() {
        delete[] data;
    }
};
```

### 5. Конструктор преобразования (Conversion Constructor)
Конструктор преобразования позволяет неявно или явно преобразовывать один тип данных в другой. Он может быть помечен как `explicit` для предотвращения неявных преобразований.

```cpp
class MyClass {
public:
    int value;
    
    MyClass(int v) : value(v) { // Конструктор преобразования
        std::cout << "Конструктор преобразования вызван\n";
    }
    
    explicit MyClass(double v) : value(static_cast<int>(v)) { // Явный конструктор преобразования
        std::cout << "Явный конструктор преобразования вызван\n";
    }
};
```

### 6. Делегирующий конструктор (Delegating Constructor)
Делегирующий конструктор позволяет одному конструктору вызывать другой конструктор того же класса для избежания дублирования кода.

```cpp
class MyClass {
public:
    int value;
    
    MyClass() : MyClass(0) { // Делегирующий конструктор
        std::cout << "Конструктор по умолчанию делегирует\n";
    }
    
    MyClass(int v) : value(v) {
        std::cout << "Параметризованный конструктор вызван\n";
    }
};
```

### 7. Конструктор списка инициализации (Initializer List Constructor)
Этот конструктор используется для инициализации элементов класса с помощью списка инициализации.

```cpp
class MyClass {
public:
    std::vector<int> values;
    
    MyClass(std::initializer_list<int> init_list) : values(init_list) { // Конструктор списка инициализации
        std::cout << "Конструктор списка инициализации вызван\n";
    }
};
```

### Примеры использования

```cpp
#include <iostream>
#include <vector>

class MyClass {
public:
    int value;
    int* data;

    // Конструктор по умолчанию
    MyClass() : value(0), data(nullptr) {
        std::cout << "Конструктор по умолчанию вызван\n";
    }

    // Параметризованный конструктор
    MyClass(int v) : value(v), data(new int[v]) {
        std::cout << "Параметризованный конструктор вызван\n";
    }

    // Конструктор копирования
    MyClass(const MyClass &other) : value(other.value), data(new int[other.value]) {
        std::copy(other.data, other.data + other.value, data);
        std::cout << "Конструктор копирования вызван\n";
    }

    // Перемещающий конструктор
    MyClass(MyClass &&other) noexcept : value(other.value), data(other.data) {
        other.data = nullptr;
        std::cout << "Перемещающий конструктор вызван\n";
    }

    // Конструктор преобразования
    MyClass(double v) : value(static_cast<int>(v)), data(new int[static_cast<int>(v)]) {
        std::cout << "Конструктор преобразования вызван\n";
    }

    // Делегирующий конструктор
    MyClass(std::initializer_list<int> init_list) : MyClass() {
        for (int val : init_list) {
            std::cout << val << " ";
        }
        std::cout << "\nКонструктор списка инициализации вызван\n";
    }

    // Деструктор
    ~MyClass() {
        delete[] data;
    }
};

int main() {
    MyClass a;                  // Конструктор по умолчанию
    MyClass b(10);              // Параметризованный конструктор
    MyClass c = b;              // Конструктор копирования
    MyClass d = MyClass(20);    // Перемещающий конструктор
    MyClass e = 3.14;           // Конструктор преобразования
    MyClass f = {1, 2, 3, 4};   // Конструктор списка инициализации

    return 0;
}
```

### Заключение

- **Конструктор по умолчанию**: без аргументов, инициализирует объект стандартным образом.
- **Параметризованный конструктор**: принимает аргументы для инициализации объекта.
- **Конструктор копирования**: создает копию другого объекта.
- **Перемещающий конструктор**: переносит ресурсы из одного объекта в другой.
- **Конструктор преобразования**: позволяет преобразовывать один тип данных в другой.
- **Делегирующий конструктор**: вызывает другой конструктор того же класса.
- **Конструктор списка инициализации**: используется для инициализации объектов с помощью списка инициализации.

Каждый тип конструктора имеет свои особенности и используется в зависимости от требований к инициализации объектов класса.

**Параметрический конструктор**

```cpp
class MyClass {
public:
    MyClass(int val) : value(val) {}
private:
    int value;
};
```

**Конструктор преобразования**

```cpp
class MyClass {
public:
    MyClass(double val) {
        // преобразование
    }
};
```

**Ключевое слово `explicit`**

```cpp
class MyClass {
public:
    explicit MyClass(double val) {
        // преобразование
    }
};
```

**Делегирующие конструкторы**

```cpp
class MyClass {
public:
    MyClass() : MyClass(0) {}
    MyClass(int val) : value(val) {}
private:
    int value;
};
```

### (b) Конструкции `=default` и `=delete`.

**Конструктор по умолчанию**

```cpp
class MyClass {
public:
    MyClass() = default;
};
```

**Запрет конструктора**

```cpp
class MyClass {
public:
    MyClass() = delete;
};
```

### (c) Деструктор. Идиома RAII. Порядок вызова конструкторов и деструкторов. Правило трех.

**Деструктор**

```cpp
class MyClass {
public:
    ~MyClass() {
        // код очистки
    }
};
```

**Идиома RAII (Resource Acquisition Is Initialization)**

Конструкторы и деструкторы позволяют реализовать важнейшую идиому языка C++ — RAII (Resource Acquisition Is Initialization/Захват Ресурса - это Инициализация) Идея в том, чтобы выделение и освобождение ресурса происходило автоматически (в конструкторе и деструкторе соответственно)

```cpp
class File {
public:
    File(const char* filename) {
        file = fopen(filename, "r");
    }

    ~File() {
        if (file) {
            fclose(file);
        }
    }

private:
    FILE* file;
};
```

**Порядок вызова конструкторов и деструкторов**

Стековые объекты создаются в порядке объявления, а уничтожаются в обратном

1. Базовый класс конструктор
2. Поля класса (в порядке их объявления)
3. Конструктор производного класса

**Правило трех**

Если класс требует явного определения деструктора, конструктора копирования или оператора присваивания, то, вероятно, ему нужны все три.

```cpp
class MyClass {
public:
    ~MyClass() {
        delete[] data;
    }

    MyClass(const MyClass& other) {
        data = new int[other.size];
        std::copy(other.data, other.data + other.size, data);
    }

    MyClass& operator=(const MyClass& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            std::copy(other.data, other.data + other.size, data);
        }
        return *this;
    }

private:
    int* data;
    size_t size;
};
```

**Конструкция `=delete`**

Начиная с C++11, можно объявлять функции "удаленными". Такие функции нельзя вызывать, а также нельзя получать указатель на них.

 Как правило, эта возможность используется для запрета генерации некоторых методов (например, для запрета копирования).

```cpp
class MyClass {
public:
    MyClass(const MyClass&) = delete;
    MyClass& operator=(const MyClass&) = delete;
};
```

### 9. Сборка программ на C++ и перегрузка операций

### (a) Перегрузка операций. Правила перегрузки операций. Перегрузка побитового сдвига для потокового ввода/вывода.

**Перегрузка операций**

В C++ механизм перегрузки операций позволяет определить поведение операторов при работе с пользовательскими типами. Этот механизм называется перегрузкой операций и является примером статического полиморфизма.

**Синтаксис перегрузки операций**

```cpp
class Complex {
public:
    double re, im;

    Complex(double r = 0, double i = 0) : re(r), im(i) {}

    // Перегрузка оператора сложения
    Complex operator +(const Complex& other) const {
        return Complex(re + other.re, im + other.im);
    }
};
```

**Перегрузка унарных операций**

```cpp
// Перегрузка унарного оператора -
Complex operator -(const Complex& x) {
    return {-x.re, -x.im};
}

// Как метод класса
Complex Complex::operator -() const {
    return {-re, -im};
}
```

**Правила и особенности**

1. Нельзя переопределять операции с примитивными типами.

2. Нельзя вводить новые операции в язык.

3. Нельзя менять арность и приоритет операций.

4. Нельзя переопределять операции `::`, `.`, `?:`, `.*`.

5. Операции `=`, `()`, `[]`, `>` могут быть перегружены только как методы класса.

6. Операции `&&` и `||` теряют свойство "короткого вычисления".

   При выборе реализации операции для класса нужно помнить, что при реализации перегрузки методом класса, левый операнд всегда определен, а значит невозможно использовать неявные пребразования для него. Если такое необходимо, то стоит использовать реализацию как внешнуюю функцию.

**Перегрузка пре- и пост-инкремента и декремента**

```cpp
// Префиксный инкремент
Complex& Complex::operator ++() {
    ++re;
    return *this;
}

// Постфиксный инкремент
// тобы перегрузить постфиксную операцию надо (внезапно!) добавить фиктивный аргумент типа int .
Complex Complex::operator ++(int) {
    Complex temp = *this;
    ++re;
    return temp;
}
```

**Перегрузка операции индексирования**

перация(operator) индексирования (aka операция(operator) доступа к элементу массива) может быть перегружена только в форме метода класса и может иметь только один аргумент.

```cpp
class IntArray {
    int* buffer;
    size_t size;
public:
    int& operator [](size_t i) {
        return buffer[i];
    }

    int operator [](size_t i) const {
        return buffer[i];
    }
};
```

**Перегрузка круглых скобок**

операция(operator) "круглые скобки"(aka операция(operator) функционального вызова) может быть перегружена только в форме метода класса и может иметь сколько угодно аргументов

```cpp
struct Printer {
    void operator()(int i, const char* str, char c) const {
        std::cout << i << ' ' << str << ' ' << c;
    }
};

Printer print;
print(1, "Hello", '+'); // 1 Hello +
```

**Перегрузка побитового сдвига**

В C++ можно перегружать операторы, включая побитовые операторы сдвига (`<<` и `>>`). Эти операторы часто перегружаются для реализации удобного синтаксиса для ввода-вывода или других операций, специфичных для класса. Например, в стандартной библиотеке C++ оператор `<<` перегружен для потоков вывода, таких как `std::cout`.

### Пример: Перегрузка оператора `<<` для пользовательского класса

Рассмотрим класс `Point`, представляющий точку в двумерном пространстве. Мы хотим перегрузить оператор `<<`, чтобы иметь возможность удобно выводить объект этого класса на экран.

```cpp
#include <iostream>

class Point {
public:
    int x, y;

    Point(int x = 0, int y = 0) : x(x), y(y) {}

    // Перегрузка оператора << для вывода объекта Point
    friend std::ostream& operator<<(std::ostream &out, const Point &p) {
        out << "(" << p.x << ", " << p.y << ")";
        return out;
    }
};

int main() {
    Point p1(1, 2);
    Point p2(3, 4);

    std::cout << "Point 1: " << p1 << std::endl;
    std::cout << "Point 2: " << p2 << std::endl;

    return 0;
}
```

### Объяснение

1. **Класс `Point`**:
   - Содержит два поля: `x` и `y`, представляющие координаты точки.
   - Конструктор инициализирует эти поля.

2. **Перегрузка оператора `<<`**:
   - Оператор `<<` перегружен как дружественная функция класса `Point`.
   - Функция принимает ссылку на поток вывода `std::ostream` и константную ссылку на объект `Point`.
   - Функция формирует строку, представляющую точку, и добавляет её в поток вывода.
   - Возвращает ссылку на поток вывода, чтобы позволить цепочку вызовов оператора `<<`.

### Пример: Перегрузка оператора `>>` для пользовательского класса

Теперь рассмотрим пример перегрузки оператора `>>` для ввода значений координат точки.

```cpp
#include <iostream>

class Point {
public:
    int x, y;

    Point(int x = 0, int y = 0) : x(x), y(y) {}

    // Перегрузка оператора >> для ввода объекта Point
    friend std::istream& operator>>(std::istream &in, Point &p) {
        in >> p.x >> p.y;
        return in;
    }

    // Перегрузка оператора << для вывода объекта Point
    friend std::ostream& operator<<(std::ostream &out, const Point &p) {
        out << "(" << p.x << ", " << p.y << ")";
        return out;
    }
};

int main() {
    Point p;

    std::cout << "Введите координаты точки (x y): ";
    std::cin >> p;

    std::cout << "Введенная точка: " << p << std::endl;

    return 0;
}
```

### Объяснение

1. **Перегрузка оператора `>>`**:
   - Оператор `>>` перегружен как дружественная функция класса `Point`.
   - Функция принимает ссылку на поток ввода `std::istream` и ссылку на объект `Point`.
   - Функция считывает значения координат `x` и `y` из потока ввода и присваивает их полям объекта `Point`.
   - Возвращает ссылку на поток ввода, чтобы позволить цепочку вызовов оператора `>>`.

### Пример: Перегрузка побитовых операторов сдвига для пользовательского класса

Побитовые операторы сдвига (`<<` и `>>`) также могут быть перегружены для реализации специфического поведения. Например, для класса, представляющего большое целое число.

```cpp
#include <iostream>
#include <bitset>

class BigInt {
private:
    std::bitset<64> bits;

public:
    BigInt(uint64_t value = 0) : bits(value) {}

    // Перегрузка оператора << для побитового сдвига влево
    BigInt operator<<(int shift) const {
        return BigInt(bits.to_ullong() << shift);
    }

    // Перегрузка оператора >> для побитового сдвига вправо
    BigInt operator>>(int shift) const {
        return BigInt(bits.to_ullong() >> shift);
    }

    // Перегрузка оператора << для вывода объекта BigInt
    friend std::ostream& operator<<(std::ostream &out, const BigInt &b) {
        out << b.bits;
        return out;
    }
};

int main() {
    BigInt b(1024);

    std::cout << "BigInt: " << b << std::endl;
    std::cout << "BigInt << 2: " << (b << 2) << std::endl;
    std::cout << "BigInt >> 2: " << (b >> 2) << std::endl;

    return 0;
}
```

### Объяснение

1. **Класс `BigInt`**:
   - Содержит объект `std::bitset<64>`, представляющий большое целое число.
   - Конструктор инициализирует объект с помощью `uint64_t` значения.

2. **Перегрузка операторов `<<` и `>>` для побитового сдвига**:
   - Перегружаем оператор `<<` для выполнения побитового сдвига влево.
   - Перегружаем оператор `>>` для выполнения побитового сдвига вправо.
   - Эти операторы возвращают новый объект `BigInt` с результатом сдвига.

3. **Перегрузка оператора `<<` для вывода**:
   - Перегружаем оператор `<<` для вывода объекта `BigInt` в поток.
   - Используем внутреннее представление `std::bitset` для вывода.

### Заключение

Перегрузка операторов позволяет создавать удобный и интуитивно понятный синтаксис для работы с пользовательскими классами. Операторы `<<` и `>>` могут быть перегружены для ввода-вывода объектов, а также для реализации специфических операций, таких как побитовые сдвиги для классов, представляющих числа или другие структуры данных.

Перегрузка операторов побитового сдвига (`<<` и `>>`) часто используется для потокового ввода/вывода:

```cpp
class Complex {
public:
    double re, im;

    friend std::ostream& operator<<(std::ostream& os, const Complex& c) {
        os << c.re << " + " << c.im << "i";
        return os;
    }

    friend std::istream& operator>>(std::istream& is, Complex& c) {
        is >> c.re >> c.im;
        return is;
    }
};
```

### (b) One Definition Rule. Директива #include, проблема двойного включения, стражи включения.

**One Definition Rule (ODR)**

Правило одной дефиниции (ODR) требует, чтобы каждая сущность (переменная, функция, класс) имела одну и только одну определение в программе.

**Директива `#include`**

```cpp
#include <iostream>
#include "my_header.h"
```

**Проблема двойного включения**

Двойное включение одного и того же заголовочного файла может привести к ошибкам компиляции из-за повторного определения тех же сущностей.

**Стражи включения**

Стражи включения предотвращают двойное включение заголовочных файлов:

```cpp
#ifndef MY_HEADER_H
#define MY_HEADER_H

// Содержимое заголовочного файла

#endif // MY_HEADER_H
```

### (c) Сборка программ на C++. Раздельная компиляция, модули (до C++20). Встраиваемые функции и переменные. Внутреннее и внешнее связывание (`static`, `extern`).

**Раздельная компиляция**

Программы на C++ могут быть разбиты на несколько файлов, которые компилируются отдельно и затем связываются вместе.

**Модули (до C++20)**

До C++20 модули реализовывались с помощью раздельной компиляции и заголовочных файлов.

**Встраиваемые функции и переменные**

Встраиваемые функции могут быть определены с помощью ключевого слова `inline`, что позволяет компилятору вставлять их тело вместо вызова функции.

```cpp
inline int add(int a, int b) {
    return a + b;
}
```

**Внутреннее и внешнее связывание**

**Внутреннее связывание** (`static`) ограничивает видимость и использование переменной или функции только текущим файлом.

**Внешнее связывание** (`extern`) позволяет переменной или функции быть объявленными в одном файле и использоваться в других.

- **`static`**: Ограничивает область видимости переменной или функции до текущего файла.

```cpp
static int counter = 0;
```

- **`extern`**: Указывает, что переменная или функция определена в другом месте.

```cpp
extern int globalVar;
```

### (d) Пространства имен, директивы `using` и `using namespace`.

**Пространства имен**

Пространство имен (namespace) в C++ — это механизм, который позволяет организовать код и избежать конфликтов имен. Пространства имен помогают группировать логически связанные классы, функции, переменные и другие элементы, чтобы предотвратить их пересечение с элементами из других библиотек или частей программы.

### Основные особенности пространства имен

1. **Разделение кода**:
   - Пространства имен помогают разделять код, принадлежащий различным модулям или библиотекам, предотвращая конфликты имен.
2. **Улучшение читаемости кода**:
   - Пространства имен делают код более организованным и читаемым, показывая, к какому модулю или библиотеке относится конкретный элемент.
3. **Избежание конфликтов имен**:
   - При использовании большого количества библиотек и модулей, пространства имен предотвращают конфликты между элементами с одинаковыми именами.

Пространства имен используются для организации кода и предотвращения конфликтов имен:

```cpp
namespace MyNamespace {
    void myFunction() {
        // ...
    }
}
```

**Директивы `using` и `using namespace`**

- **`using`**: Делает конкретные имена доступными без необходимости полного квалифицирования.

```cpp
using MyNamespace::myFunction;
```

- **`using namespace`**: Делает все имена из пространства имен доступными.

```cpp
using namespace MyNamespace;
```

### 10. Функциональные объекты и алгоритмы

### (a) Функторы. Классы с перегруженной операцией функционального вызова. Лямбда-выражения.

**Функторы**

Функтор — это объект, который можно использовать как функцию. Для этого необходимо перегрузить оператор `()`:

```cpp
struct Adder {
    int operator()(int a, int b) const {
        return a + b;
    }
};

Adder add;
int sum = add(2, 3); // 5
```

**Лямбда-выражения**

Лямбда-выражения — это анонимные функции, которые могут быть определены на месте:

```cpp
auto add = [](int a, int b) {
    return a + b;
};

int sum = add(2, 3); // 5
```

**Список захвата**

Лямбда-выражения могут захватывать переменные из окружающей области видимости:

```cpp
int x = 10;
auto lambda = [x](int y) {
    return x + y;
};

int result = lambda(5); // 15
```

### (b) Алгоритмы. Модифицирующие алгоритмы. Немодифицирующие алгоритмы. Алгоритмы сортировки. Алгоритмы упорядоченных последовательностей. Алгоритмы для работы с пирамидой.

**Модифицирующие алгоритмы**

Примеры модифицирующих алгоритмов включают `std::copy`, `std::transform`, `std::fill`.

```cpp
std::vector<int> vec(10);
std::fill(vec.begin(), vec.end(), 1);
```

**Немодифицирующие алгоритмы**

Примеры немодифицирующих алгоритмов включают `std::find`, `std::count`, `std::accumulate`.

```cpp
std::vector<int> vec = {1, 2, 3, 4, 5};
int sum = std::accumulate(vec.begin(), vec.end(), 0); // 15
```

**Алгоритмы сортировки**

Примеры алгоритмов сортировки включают `std::sort`, `std::stable_sort`.

```cpp
std::vector<int> vec = {5, 3, 1, 4, 2};
std::sort(vec.begin(), vec.end()); // 1, 2, 3, 4, 5
```

**Алгоритмы упорядоченных последовательностей**

Примеры включают `std::merge`, `std::includes`.

`std::includes` — это функция в стандартной библиотеке C++ (включена в заголовок `<algorithm>`), которая проверяет, является       ли одна отсортированная последовательность подмножеством другой отсортированной последовательности. Другими словами, `std::includes` проверяет, содержатся ли все элементы одной последовательности в другой последовательности.

```cpp
std::vector<int> a = {1, 3, 5};
std::vector<int> b = {2, 4, 6};
std::vector<int> result(6);

std::merge(a.begin(), a.end(), b.begin(), b.end(), result.begin());
```

**Алгоритмы для работы с пирамидой**

Примеры включают `std::make_heap`, `std::push_heap`, `std::pop_heap`.

```cpp
std::vector<int> vec = {3, 1, 4, 1, 5, 9};
std::make_heap(vec.begin(), vec.end());
std::pop_heap(vec.begin(), vec.end());
vec.pop_back(); // удаление наибольшего элемента
``

`

Эти конспекты обеспечивают полное покрытие запросов, предоставляя необходимые примеры и детали для каждого из запросов.
```

### 11. Контейнеры

#### (a) Последовательные контейнеры: `std::array`, `std::vector`, `std::deque`, `std::list`, `std::forward_list`, `std::initializer_list`

##### `std::array`

- **Правила работы**: `std::array` - это обертка над C-массивом, предоставляющая стандартные методы работы с массивом.

- Операции и методы

  :

  - `at(size_t idx)`: доступ к элементу с проверкой границ.
  - `operator[]`: доступ к элементу без проверки границ.
  - `front()`: ссылка на первый элемент.
  - `back()`: ссылка на последний элемент.
  - `data()`: указатель на внутренний массив.
  - `size()`: размер массива.
  - `empty()`: проверка на пустоту.

##### `std::vector`

- Инициализация

  :

  - `std::vector<int> v1;`: пустой вектор.
  - `std::vector<int> v2(10);`: вектор из 10 элементов, инициализированных по умолчанию.
  - `std::vector<int> v3(10, 5);`: вектор из 10 элементов, инициализированных значением 5.
  - `std::vector<int> v4{1, 2, 3, 4, 5};`: список инициализации.

- Доступ к элементам

  :

  - `v.at(0)`: доступ к элементу с проверкой границ.
  - `v[0]`: доступ к элементу без проверки границ.
  - `v.front()`: первый элемент.
  - `v.back()`: последний элемент.
  - `v.data()`: указатель на данные.

- Вставка и удаление элементов

  :

  - `v.push_back(5)`: добавление элемента в конец.
  - `v.pop_back()`: удаление последнего элемента.
  - `v.insert(v.begin(), 10)`: вставка элемента в начало.
  - `v.erase(v.begin())`: удаление первого элемента.
  - `v.clear()`: удаление всех элементов.

- Управление хранилищем

  :

  - `v.reserve(100)`: резервирование памяти для 100 элементов.
  - `v.shrink_to_fit()`: уменьшение выделенной памяти до текущего размера.

- Полезные советы

  :

  - `v.capacity()`: текущая емкость.
  - `v.size()`: текущий размер.

- Инвалидация ссылок и указателей

  :

  - Вставка и удаление могут инвалидировать ссылки, указатели и итераторы на элементы.

##### `std::deque`

- Инвалидация ссылок и указателей

  :В силу того, что хранилище массива может менять свой размер, ему необходимо перевыделять память. А значит место в памяти изменяется при изменении самого массива, значит следующий код не считается валидным:

  - Вставка и удаление элементов могут инвалидировать ссылки и указатели на элементы.

##### `std::list`

\- шаблонный класс двусвязного списка.

- Методы

  :Преимуществом списков является то, что можно быстро (за O(1)) перенести элементы одного списка в другой или переставить элементы списка внутри него самого.

  l . splice ( pos , other );

  - `push_front()`: вставка в начало.
  - `push_back()`: вставка в конец.
  - `pop_front()`: удаление первого элемента.
  - `pop_back()`: удаление последнего элемента.
  - `insert()`: вставка элемента.
  - `erase()`: удаление элемента.
  - `clear()`: очистка списка.

##### `std::forward_list`

std::forward_list — шаблонный класс односвязного списка.

- Типы-члены

  :

  - `iterator`: итератор.
  - `const_iterator`: константный итератор.
  - `size_type`: беззнаковый целочисленный тип.

#### (b) Ассоциативные контейнеры: `std::map`, `std::set`, `unordered-` и `multi-` версии

##### `std::set` / `std::multiset`

• Compare - функтор, т.е. тип, у которого определена операция(operator) () , принимающая два объекта KeyT и возвращающая true , если первый операнд меньше (строго!) второго. 

• Элементы упорядочены по ключу согласно сравнению Compare .

 • Обеспечивают логарифмический поиск, вставку и удаление элементов.

 • Как правило, реализованы с помощью бинарного дерева поиска.

- Конструкторы

  :

  - Пустой конструктор: `std::set<int> s;`.
  - Конструктор с диапазоном: `std::set<int> s(arr.begin(), arr.end());`.
  - Конструктор с инициализатором: `std::set<int> s = {1, 2, 3};`.

- Поиск

  :

  - `s.find(key)`: возвращает итератор на элемент или `end()`, если элемент не найден.

- Вставка

  :

  - `s.insert(key)`: вставка элемента, возвращает пару (успех/неуспех и итератор на элемент).
  - `s.emplace(args...)`: вставляет элемент с параметрами конструктора.

- Удаление

  :

  - `s.erase(key)`: удаляет элемент по ключу.

- Прочее

  :

  - `empty()`: проверка на пустоту.
  - `size()`: количество элементов.
  - `clear()`: очистка контейнера.

- Изменение ключа

  :

  - Невозможно изменить ключ напрямую, только удаление и вставка нового элемента.

##### `std::map` / `std::multimap`

- Методы

  :

  - `operator[]`: доступ к элементу с созданием значения по умолчанию, если ключа нет.
  - `at(key)`: доступ к элементу с выбросом исключения, если ключа нет.

- Изменение ключа

  :

  - Аналогично `std::set`, изменение ключа возможно через удаление и вставку.

##### `std::unordered`

- Контейнеры:

  - `std::unordered_set`, `std::unordered_map`, `std::unordered_multiset`, `std::unordered_multimap`.
  - Более эффективные операции (поиск, вставка, удаление) по сравнению с ассоциативными контейнерами.
  - Не хранят порядок элементов.

- Дополнительные методы

  :

  - `float load_factor() const`: возвращает отношение числа элементов к числу корзин.
  - `float max_load_factor() const`: возвращает значение load_factor, при котором происходит перехеширование.
  - `void max_load_factor(float)`: устанавливает значение load_factor.
  - `rehash(count)`: изменяет число корзин на count.
  - `reserve(count)`: устанавливает число корзин для хранения count элементов.

#### (c) Контейнерные адаптеры: `std::stack`, `std::queue`, `std::priority_queue`

##### `std::stack`

- Методы

  :

  - `push()`: добавление элемента на вершину стека.
  - `pop()`: удаление элемента с вершины стека.
  - `top()`: доступ к элементу на вершине стека.
  - `empty()`: проверка на пустоту.
  - `size()`: количество элементов.

##### `std::queue`

- Методы

  :

  - `push()`: добавление элемента в конец очереди.
  - `pop()`: удаление элемента из начала очереди.
  - `front()`: доступ к первому элементу.
  - `back()`: доступ к последнему элементу.
  - `empty()`: проверка на пустоту.
  - `size()`: количество элементов.

##### `std::priority_queue`

- Методы

  :

  - `push()`: добавление элемента.
  - `pop()`: удаление элемента с наивысшим приоритетом.
  - `top()`: доступ к элементу с наивысшим приоритетом.
  - `empty()`: проверка на пустоту.
  - `size()`: количество элементов.

##### `initializer_list`

- Пример и синтаксис

  :`std::initializer_list` — это стандартный контейнер в C++, который представляет собой неизменяемый массив объектов одного типа, проинициализированных с помощью списка инициализации. Он полезен для передачи произвольного количества аргументов в функцию или для инициализации контейнеров.

  ```c++
  cpp
  Копировать код
  std::initializer_list<int> init_list = {1, 2, 3, 4, 5};
  ```

##### `Structured bindings (структурные связывания)`

- Инициализация

  :

  ```c++
  cppКопировать кодstd::tuple<int, double, std::string> tpl(1, 2.3, "hello");
  auto [i, d, s] = tpl;
  ```

# 12. Наследование и Статический полиморфизм

#### (a) Наследование. Модификаторы доступа при наследовании. Конструкторы и деструкторы при наследовании.

**Наследование**

Наследование в C++ — это механизм объектно-ориентированного программирования, который позволяет создавать новые классы на основе существующих. Новый класс, называемый производным (или подклассом), наследует свойства и методы базового класса (или суперкласса). Это позволяет повторно использовать код и создавать более сложные иерархии классов.

### Основные понятия:

1. **Базовый класс (Base class)**: Класс, от которого наследуют другие классы.
2. **Производный класс (Derived class)**: Класс, который наследует от базового класса.

### Виды наследования:

1. **Публичное наследование (public inheritance)**:
   - Все публичные члены базового класса становятся публичными членами производного класса.
   - Протектед члены базового класса становятся протектед членами производного класса.

   ```cpp
   class Base {
   public:
       int publicMember;
   protected:
       int protectedMember;
   private:
       int privateMember;
   };
   
   class Derived : public Base {
       // publicMember - публичный
       // protectedMember - защищенный
       // privateMember - не доступен
   };
   ```

2. **Защищенное наследование (protected inheritance)**:
   - Публичные и защищенные члены базового класса становятся защищенными членами производного класса.

   ```cpp
   class Derived : protected Base {
       // publicMember - защищенный
       // protectedMember - защищенный
       // privateMember - не доступен
   };
   ```

3. **Приватное наследование (private inheritance)**:
   - Публичные и защищенные члены базового класса становятся приватными членами производного класса.

   ```cpp
   class Derived : private Base {
       // publicMember - приватный
       // protectedMember - приватный
       // privateMember - не доступен
   };
   ```

### Пример:

```cpp
#include <iostream>

class Animal {
public:
    void eat() {
        std::cout << "Eating" << std::endl;
    }
};

class Dog : public Animal {
public:
    void bark() {
        std::cout << "Barking" << std::endl;
    }
};

int main() {
    Dog myDog;
    myDog.eat();  // Наследованный метод
    myDog.bark(); // Метод производного класса
    return 0;
}
```

В этом примере класс `Dog` наследует класс `Animal`, что позволяет объекту `myDog` использовать метод `eat()` из базового класса и метод `bark()` из собственного класса.

### Ключевые моменты:

- **Переопределение (Overriding)**: Производный класс может переопределять методы базового класса для изменения их поведения.
- **Виртуальные функции (Virtual functions)**: Позволяют производным классам переопределять методы базового класса, поддерживая полиморфизм.
- **Конструкторы и деструкторы**: Конструкторы базового класса не наследуются, но могут быть вызваны из конструктора производного класса. Деструкторы должны быть виртуальными, если используется полиморфизм.

Наследование является мощным инструментом в C++, позволяющим создавать иерархии классов и улучшать повторное использование кода.

Наследование позволяет одному классу (производный класс) использовать данные и методы другого класса (базовый класс). Наследование делится на три типа в зависимости от уровня доступа: `public`, `protected` и `private`.

**Модификаторы доступа при наследовании**

- `public` наследование — все публичные и защищенные члены базового класса становятся публичными и защищенными членами производного класса.
- `protected` наследование — все публичные и защищенные члены базового класса становятся защищенными членами производного класса.
- `private` наследование — все публичные и защищенные члены базового класса становятся приватными членами производного класса.

```cpp
struct A {
public: 
    int x;
private: 
    void f();
};

struct B : public A {
    void h() {
        x = 0; // Ok
        f(); // CE
    }
};

struct C : private A {
    void h() {
        x = 0; // Ok
        f(); // CE
    }
};

A a;
a.x = 11; // Ok
a.f(); // CE

B b;
b.x = 11; // Ok
b.f(); // CE

C c;
c.x = 11; // CE
c.f(); // CE
```

[Конспект-2, стр. 137](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=137).

**Конструкторы и деструкторы при наследовании**

Класс инициализируется в следующем порядке: сначала инициализируются базовые классы, затем поля класса-наследника в порядке объявления.

```cpp
struct A {
    int x;
    int y;
    A(int);
    A(int, int);
};

struct B : public A {
    B(int a, int b) : A(a), z(b) {}
    int z;
};
```

[Конспект-2, стр. 142](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=142).

#### (b) Срезка. Затенение методов базового класса. Работа с производными классами через указатель или ссылку на базовый.

### Затенение методов базового класса (Shadowing)

Затенение (или скрытие) происходит, когда производный класс определяет метод, который имеет то же имя (и параметры) как у метода базового класса. В результате, метод базового класса становится "затененным" или "скрытым" в контексте производного класса.

#### Пример затенения:

```cpp
#include <iostream>

class Base {
public:
    void display() {
        std::cout << "Display from Base" << std::endl;
    }
};

class Derived : public Base {
public:
    void display() {
        std::cout << "Display from Derived" << std::endl;
    }
};

int main() {
    Derived d;
    d.display(); // Вызывает display() из Derived, затеняя display() из Base
    return 0;
}
```

В этом примере метод `display` в классе `Derived` затеняет метод `display` в классе `Base`. Когда мы вызываем `d.display()`, вызывается версия из `Derived`.

#### Как вызвать метод базового класса:

Чтобы вызвать затененный метод базового класса, нужно использовать оператор разрешения области видимости (`::`):

```cpp
int main() {
    Derived d;
    d.display();          // Вызывает display() из Derived
    d.Base::display();    // Вызывает display() из Base
    return 0;
}
```

### Срезка (Slicing)

Срезка происходит, когда объект производного класса копируется в объект базового класса. В результате, специфические для производного класса данные и поведение "срезаются", остаются только данные и поведение базового класса.

#### Пример срезки:

```cpp
#include <iostream>

class Base {
public:
    int baseVar;

    void display() {
        std::cout << "Base display: " << baseVar << std::endl;
    }
};

class Derived : public Base {
public:
    int derivedVar;

    void display() {
        std::cout << "Derived display: " << baseVar << ", " << derivedVar << std::endl;
    }
};

void printBase(Base b) {
    b.display();
}

int main() {
    Derived d;
    d.baseVar = 1;
    d.derivedVar = 2;
    printBase(d); // Происходит срезка, вызывается Base::display(), теряется derivedVar
    return 0;
}
```

В этом примере объект `d` класса `Derived` передается по значению в функцию `printBase`, которая принимает параметр типа `Base`. Происходит срезка, и специфическое для `Derived` поведение теряется. В результате вызывается метод `Base::display`, и информация о `derivedVar` теряется.

### Как избежать срезки:

Чтобы избежать срезки, следует передавать объекты по ссылке или указателю:

```cpp
void printBase(const Base& b) {
    b.display();
}

int main() {
    Derived d;
    d.baseVar = 1;
    d.derivedVar = 2;
    printBase(d); // Нет срезки, если display() виртуальный, вызывается Derived::display
    return 
```



**Работа с производными классами через указатель или ссылку на базовый**

### Пример

Рассмотрим пример, демонстрирующий использование полиморфизма через указатели и ссылки:

```cpp
#include <iostream>

// Базовый класс
class Base {
public:
    virtual void show() {
        std::cout << "Base show" << std::endl;
    }
    
    virtual ~Base() {} // Виртуальный деструктор
};

// Производный класс
class Derived : public Base {
public:
    void show() override {
        std::cout << "Derived show" << std::endl;
    }
};

void display(Base& obj) {
    obj.show(); // Вызов виртуальной функции
}

int main() {
    Base base;
    Derived derived;
    
    // Использование ссылки на базовый класс
    display(base);    // Вызывает Base::show
    display(derived); // Вызывает Derived::show
    
    // Использование указателя на базовый класс
    Base* ptr = &derived;
    ptr->show(); // Вызывает Derived::show
    
    return 0;
}
```



```cpp
class Base {
public:
    void f() {
        std::cout << "Base";
    }
};

class Derived : public Base {
public:
    void f() {
        std::cout << "Derived";
    }
};

Base* b = new Derived();
b->f(); // Вызывает Base::f()
```

[Конспект-2, стр. 145](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=145).

For more detailed information, please refer to the [document](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf).

# 13. Динамический полиморфизм

#### (a) Динамический полиморфизм. Виртуальные функции. Идентификаторы `override` и `final`. Ковариантные возвращаемые типы.

**Динамический полиморфизм**

Напоминание: Полиморфизм - свойство системы, позволяющее использовать различные реализации в рамках одного интерфейса. Статический полиморфизм - вид полиморфизма, при котором выбор реализации осуществляется на этапе компиляции (перегрузка функций, шаблоны, перегрузка операций и т.д). Динамический полиморфизм - вид полиморфизма, при котором выбор реализации осуществляется во время выполнения программы. Основной механизм реализации динамического полиморфизма в C++ - виртуальные функции.

```cpp
struct A {
    virtual void f() { std::cout << "A"; }
};

struct B : public A {
    void f() override { std::cout << "B"; }
};

A* ptr = new B;
ptr->f(); // Выведет "B"
```

[Динамический полиморфизм, стр. 148](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=148).

**Виртуальные функции**

Виртуальная функция — это функция-член, которая переопределяется в производном классе и вызывается через указатель или ссылку на базовый класс. Примеры применения:

```cpp
struct A {
    virtual void f() { std::cout << "A"; }
    A() { f(); }
    ~A() { f(); }
};

struct B : public A {
    void f() { std::cout << "B"; }
    B() { f(); }
    ~B() { f(); }
};

B b; // A B B A
```

[Виртуальные функции, стр. 148](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=148).

**Идентификаторы `override` и `final`**

- `override` используется для явного указания, что функция переопределяет виртуальную функцию базового класса.
- `final` используется для запрета дальнейшего переопределения виртуальной функции.

```cpp
struct A {
    virtual void f();
};

struct B : public A {
    void f() override; // переопределение
};

struct C : public B {
    void f() final; // запрещает дальнейшее переопределение
};
```

[Идентификаторы `override` и `final`, стр. 151](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=151).

**Ковариантные возвращаемые типы**

Типы называются ковариантными, если они являются указателями или ссылками и ссылаются на родственные классы (предок-потомок).

Если виртуальная функция возвращает указатель или ссылку на класс, то при переопределении этой функции можно вернуть указатель или ссылку на производный класс.

```cpp
struct A {
    virtual A* Clone() const { return new A(*this); }
};

struct B : public A {
    B* Clone() const override { return new B(*this); }
};
```

[Ковариантные возвращаемые типы, стр. 152](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=152).

#### (b) Виртуальный деструктор. Позднее и раннее связывание, таблица виртуальных функций.

**Виртуальный деструктор**

Если в классе имеются виртуальные функции, то для корректного удаления объектов через указатель на базовый класс необходимо объявлять деструктор виртуальным.

```cpp
class Base {
public:
    virtual ~Base() = default;
};

class Derived : public Base {
public:
    ~Derived() override = default;
};

Base* base = new Derived();
delete base; // вызовется деструктор Derived, а затем Base
```

[Виртуальный деструктор, стр. 149](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=149).

**Позднее и раннее связывание, таблица виртуальных функций**

В C++ связывание бывает двух видов: раннее и позднее. Они определяют, как и когда компилятор связывает вызов функции с ее определением. Связывание связано с полиморфизмом и механизмом виртуальных функций.

### Раннее связывание (Early Binding)

- **Определение**: Раннее связывание (также называемое статическим связыванием) происходит во время компиляции. Компилятор определяет, какую функцию вызывать, основываясь на типе указателя или ссылки.
- **Характеристика**: Обычно используется для невиртуальных функций.
- **Пример**:
  ```cpp
  class Base {
  public:
      void show() {
          std::cout << "Base show" << std::endl;
      }
  };
  
  class Derived : public Base {
  public:
      void show() {
          std::cout << "Derived show" << std::endl;
      }
  };
  
  int main() {
      Base b;
      Derived d;
      Base* ptr = &d;
      ptr->show(); // Вызывает Base::show, потому что связывание происходит во время компиляции
      return 0;
  }
  ```

### Позднее связывание (Late Binding)

- **Определение**: Позднее связывание (также называемое динамическим связыванием) происходит во время выполнения. Компилятор не знает, какую функцию вызывать, до тех пор, пока программа не будет запущена.
- **Характеристика**: Используется для виртуальных функций.
- **Пример**:
  ```cpp
  class Base {
  public:
      virtual void show() {
          std::cout << "Base show" << std::endl;
      }
      virtual ~Base() {} // Виртуальный деструктор
  };
  
  class Derived : public Base {
  public:
      void show() override {
          std::cout << "Derived show" << std::endl;
      }
  };
  
  int main() {
      Base b;
      Derived d;
      Base* ptr = &d;
      ptr->show(); // Вызывает Derived::show, потому что связывание происходит во время выполнения
      return 0;
  }
  ```

### Таблица виртуальных функций (VTable)

- **Определение**: Таблица виртуальных функций (VTable) — это механизм, используемый компилятором для поддержки позднего связывания. Она представляет собой таблицу указателей на виртуальные функции.
- **Как это работает**:
  - Когда класс содержит виртуальные функции, компилятор создает VTable для этого класса.
  - Каждый объект класса содержит указатель на VTable (так называемый vptr).
  - Когда виртуальная функция вызывается через указатель или ссылку на базовый класс, программа использует VTable для определения правильной функции.
- **Пример**:
  ```cpp
  class Base {
  public:
      virtual void show() {
          std::cout << "Base show" << std::endl;
      }
      virtual ~Base() {} // Виртуальный деструктор
  };
  
  class Derived : public Base {
  public:
      void show() override {
          std::cout << "Derived show" << std::endl;
      }
  };
  
  int main() {
      Base* ptr = new Derived();
      ptr->show(); // Использует VTable для вызова Derived::show
      delete ptr;
      return 0;
  }
  ```
  В этом примере при вызове `ptr->show()`, компилятор использует указатель vptr на VTable для определения, какую функцию `show` вызывать. Поскольку `ptr` указывает на объект `Derived`, вызывается функция `Derived::show`.

### Заключение

Раннее и позднее связывание определяют, как и когда компилятор связывает вызовы функций с их реализациями. Раннее связывание происходит во время компиляции и обычно используется для невиртуальных функций. Позднее связывание происходит во время выполнения и используется для виртуальных функций, позволяя динамически определять, какую функцию вызывать. Таблица виртуальных функций (VTable) является ключевым механизмом, обеспечивающим позднее связывание в C++, позволяя объектам корректно вызывать переопределенные методы производных классов.

[Позднее и раннее связывание, стр. 150](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=150).

#### (c) Чисто виртуальные функции. Абстрактные классы.

**Чисто виртуальные функции**

Чисто виртуальная функция — это функция, объявленная в базовом классе и не имеющая реализации в нем. Она обозначается `= 0`.

```cpp
struct A {
    virtual void f() = 0;
};

struct B : public A {
    void f() override { std::cout << "B"; }
};
```

[Чисто виртуальные функции, стр. 153](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=153).

**Абстрактные классы**

Абстрактный класс — это класс, содержащий хотя бы одну чисто виртуальную функцию. Объекты абстрактного класса не могут быть созданы.

```cpp
class Message {
public:
    virtual void Display() const = 0; // чисто виртуальная функция
};

class TextMessage : public Message {
public:
    void Display() const override {
        // реализация отображения текстового сообщения
    }
};
```

[Абстрактные классы, стр. 153](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=153).

# 14. Исключения

#### (a) Исключения. Ключевое слово throw. Блок catch.

**Исключения**

Исключение - это объект, который генерируется при возникновении исключительной ситуации (ошибки). Исключения позволяют разделить обработку ошибок от основной логики программы.

**Ключевое слово throw**

Генерация ошибки происходит с помощью оператора `throw`:

```cpp
template <class T>
T Divide(T x, T y) {
    if (y == 0) { throw 1; } // Исключение типа int, значение 1
    return x / y;
}
```

После выполнения `throw` работа функции прекращается, вызываются деструкторы для объектов на стеке, и управление передается на ближайший соответствующий `catch` блок.

[Конспект-2, стр. 173-174](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=173).

**Блок catch**

Конструкция `try-catch` позволяет перехватывать и обрабатывать исключения:

```cpp
int main() {
    try {
        Divide(1, 0);
    } catch (int err) {
        std::cout << "DivisionError: error code " << err << '\n';
    }
    return 0;
}
```

Исключение, возникшее в блоке `try`, может быть поймано в соответствующем блоке `catch`. После завершения блока `catch` исключение считается успешно обработанным, и выполнение программы продолжается в нормальном режиме.

[Конспект-2, стр. 174](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=174).

**Множественные catch блоки**

Одному блоку `try` может соответствовать несколько блоков `catch`:

```cpp
int main() {
    try {
        Divide(1, 0);
    } catch (double err) {
        std::cout << "Caught double\n";
    } catch (int err) {
        std::cout << "Caught int\n";
    }
    return 0;
}
```

Только один блок `catch`, соответствующий типу брошенного исключения, будет выполнен.

[Конспект-2, стр. 175](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=175).

**Специальная форма throw без аргументов**

Существует особая форма оператора `throw` без аргумента - `throw;`. Она означает "снова бросить пойманное исключение".

```cpp
void f() {
    auto ptr = new int(11);
    try {
        g(ptr); // potentially throws an exception of type A
    } catch (A& a) {
        delete ptr;
        throw; // throw old exception
    }
    delete ptr;
}
```

[Конспект-2, стр. 177](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=177).

#### (b) Статическая спецификация исключений. Ключевое слово noexcept (спецификатор, условный спецификатор, операция). Исключения в конструкторах и деструкторах.

**Статическая спецификация исключений (C++11)**

**Спецификатор noexcept (C++11)**

Чтобы пообещать компилятору, что функция не будет бросать исключений, можно воспользоваться спецификатором `noexcept`:

```cpp
void f() noexcept {
    // ...
}
```

Если обещание будет нарушено, и исключение вылетит из `noexcept` функции, то программа завершится аварийно (без возможности перехватить исключение).

[Конспект-2, стр. 177](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=177).

**Условный спецификатор noexcept (C++11)**

Можно использовать условный спецификатор `noexcept`, чтобы установить `noexcept`, в зависимости от того, являются ли вызываемые внутри функции операции `noexcept` или нет:

```cpp
template <class T>
auto Sum(const T& x, const T& y) noexcept(noexcept(x + y)) {
    return x + y;
}
```

[Конспект-2, стр. 178](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=178).

**Исключения в конструкторах и деструкторах**

Исключения в конструкторах и деструкторах могут привести к утечкам ресурсов. Для решения этой проблемы можно использовать блок `try-catch` внутри конструктора:

```cpp
struct A {
    std::vector<int> v;
    int* ptr;
    A() : v(100), ptr(new int) {
        try {
            f(); // potentially throws an exception
        } catch (...) {
            delete ptr;
            throw;
        }
    }
    ~A() {
        delete ptr;
    }
};
```

Если конструктор не завершил работу, объект не считается созданным, и деструктор вызван не будет.

[Конспект-2, стр. 179](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=179).

#### (c) Гарантии безопасности исключений. Иерархия исключений в C++.

**Гарантии безопасности исключений**

Есть три уровня гарантий безопасности исключений:

1. **Базовая гарантия** - В случае исключения все ресурсы будут освобождены, и объект остается в валидном, но неопределенном состоянии.
2. **Сильная гарантия** - В случае исключения состояние программы остается неизменным (но может возникнуть утечка ресурсов).
3. **Гарантия отсутствия исключений** - Исключения не возникают.

**Иерархия исключений в C++**

Иерархия стандартных исключений в C++:

```cpp
#include <exception>
#include <stdexcept>

try {
    // some code
} catch (const std::logic_error& e) {
    std::cerr << "Logic error: " << e.what() << '\n';
} catch (const std::runtime_error& e) {
    std::cerr << "Runtime error: " << e.what() << '\n';
} catch (const std::exception& e) {
    std::cerr << "Exception: " << e.what() << '\n';
} catch (...) {
    std::cerr << "Unknown error\n";
}
```

Стандартная библиотека C++ определяет несколько исключений, которые наследуются от `std::exception`.

[Конспект-2, стр. 180-181](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=180).

For more detailed information, please refer to the [document](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf).

# 15. Итераторы

#### (a) Итераторы. Константные итераторы. Категории итераторов. Класс std::iterator_traits. Обобщенные функции для работы с итераторами (std::advance, std::next, std::prev, std::distance). Инвалидация итераторов. Range-based for.

**Итераторы**

Итератор — это объект, который позволяет перебирать элементы контейнера. Итераторы в C++ аналогичны указателям, но предназначены для работы с контейнерами.

**Константные итераторы**

Константные итераторы позволяют читать значения, на которые указывают, но не позволяют изменять их:

```cpp
template <class Iterator>
void ZeroAll(Iterator begin, Iterator end) {
    for (; begin != end; ++begin) {
        *begin = 0; // CE: assignment of read-only location
    }
}
const std::vector<int> cv {1, 2, 3};
ZeroAll(cv.begin(), cv.end()); // begin() и end() теперь возвращают std::vector<T>::const_iterator
```

Для получения константных итераторов у неконстантных контейнеров можно использовать методы `cbegin()` и `cend()`.

[Конспект-2, стр. 184](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=184).

**Категории итераторов**

В зависимости от поддерживаемых операций итераторы могут принадлежать следующим категориям:

- input iterator (итератор ввода)
- output iterator (итератор вывода)
- forward iterator (прямой итератор)
- bidirectional iterator (двунаправленный итератор)
- random access iterator (итератор произвольного доступа)
- contiguous iterator (непрерывный итератор) (C++20)

[Конспект-2, стр. 185](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=185).

**Класс std::iterator_traits**

Класс `std::iterator_traits` используется для получения информации о итераторах. Это позволяет создавать обобщенные алгоритмы, которые работают с разными типами итераторов.

**Обобщенные функции для работы с итераторами**

- `std::advance`: перемещает итератор на указанное количество шагов.
- `std::next`: возвращает итератор, сдвинутый на указанное количество шагов.
- `std::prev`: возвращает итератор, сдвинутый назад на указанное количество шагов.
- `std::distance`: возвращает расстояние между двумя итераторами.

```cpp
std::vector<int> v = {1, 2, 3, 4, 5};
auto it = v.begin();
std::advance(it, 2); // теперь it указывает на 3
auto next_it = std::next(it); // next_it указывает на 4
auto prev_it = std::prev(it); // prev_it указывает на 2
auto dist = std::distance(v.begin(), it); // dist == 2
```

[Конспект-2, стр. 186](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=186).

**Инвалидация итераторов**

Инвалидация итераторов происходит, когда итераторы становятся недействительными после изменения контейнера (например, при вставке или удалении элементов).

**Range-based for**

Конструкция `range-based for` используется для упрощенного перебора элементов контейнера:

```cpp
std::vector<int> v = {1, 2, 3, 4, 5};
for (int x : v) {
    std::cout << x << ' ';
}
```

[Конспект-2, стр. 184](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=184).

#### (b) Итераторные адаптеры. Итераторы вставки. Обратные итераторы. Итераторы перемещения. Потоковые итераторы.

**Итераторные адаптеры**

Итераторные адаптеры изменяют поведение стандартных итераторов для специальных целей. Основные итераторные адаптеры:

- `std::back_insert_iterator`: итератор вставки в конец контейнера.
- `std::front_insert_iterator`: итератор вставки в начало контейнера.
- `std::insert_iterator`: итератор вставки в произвольное место контейнера.

**Пример использования итератора вставки:**

```cpp
std::vector<int> v = {1, 2, 3};
std::vector<int> v2;
std::copy(v.begin(), v.end(), std::back_inserter(v2)); // v2 == {1, 2, 3}
```

[Конспект-2, стр. 185](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=185).

**Обратные итераторы**

Обратные итераторы позволяют перебирать элементы контейнера в обратном порядке:

```cpp
std::vector<int> v = {1, 2, 3, 4, 5};
for (auto it = v.rbegin(); it != v.rend(); ++it) {
    std::cout << *it << ' '; // 5 4 3 2 1
}
```

[Конспект-2, стр. 185](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=185).

**Итераторы перемещения**

Итераторы перемещения используются для переноса содержимого объектов, что позволяет избежать копирования и повысить производительность:

```cpp
std::vector<std::string> v1 = {"one", "two", "three"};
std::vector<std::string> v2(std::make_move_iterator(v1.begin()), std::make_move_iterator(v1.end()));
```

[Конспект-2, стр. 185](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=185).

**Потоковые итераторы**

Потоковые итераторы используются для чтения из и записи в потоки:

```cpp
std::istream_iterator<int> input_it(std::cin);
std::istream_iterator<int> end_of_stream;
std::vector<int> v(input_it, end_of_stream);
std::copy(v.begin(), v.end(), std::ostream_iterator<int>(std::cout, " "));
```

[Конспект-2, стр. 186](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=186).

For more detailed information, please refer to the [document](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf).

# 16. Категории значений и конструктор перемещения

#### (a) Категории значений (lvalue, rvalue). lvalue- и rvalue-ссылки. Перегрузка функций по типу ссылки.

**Категории значений**

Категория значения - вторая характеристика выражения в C++ (первая - тип). Главный вопрос, на который отвечает категория значения: материален ли результат этого выражения, то есть существует ли он в виде объекта в памяти или нет? (идентичность).

**lvalue**

lvalue - категория значений, которая обладает идентичностью (но не перемещаема). Неформально: к lvalue относится все, у чего есть постоянное место в памяти (прописка). Критерий - у выражения можно получить адрес.

```cpp
int x, y = 0;
// x - lvalue, &x - valid operation
++x;
// lvalue, &++x - valid operation
"abc";
// lvalue, &"abc" - valid operation
x + 1;
// not lvalue, &(x + 1) - invalid operation
```

[Конспект-2, стр. 154](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=154).

**rvalue**

rvalue — перемещаемая категория значений. Делится на prvalue (pure rvalue) - значение без идентичности и xvalue (expired value) - значение с идентичностью. Неформально: к rvalue относится все, что не относится к lvalue (временные значения).

```cpp
int && rry = 11; // rvalue reference, initialized to 11
int && rr2 = x++; // rvalue reference, initialized to result of x++
int & ref = rry; // Ok: variable is ALWAYS an lvalue
```

[Конспект-2, стр. 155](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=155).

**lvalue- и rvalue-ссылки**

lvalue-ссылка - это ссылка, которая может связываться с результатом lvalue выражения.

```cpp
int x = 0;
int & rx = x; // lvalue reference on x
const int & crx = x; // const lvalue reference on x
```

[Конспект-2, стр. 155](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=155).

rvalue-ссылка — это ссылка, которая может связываться с результатом rvalue выражения.

```cpp
int && rry = 11; // rvalue reference, initialized to 11
int && rr2 = f(); // rvalue reference on result of f()
```

[Конспект-2, стр. 155](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=155).

**Перегрузка функций по типу ссылки**

По виду ссылки можно перегружать функции. Тогда результат lvalue выражений будет вызывать версию с левой ссылкой, а результат rvalue выражений - с правой. 

```cpp
template <class T>
const T * AddressOf(const T & value) {
    return &value;
}

template <class T>
const T * AddressOf(const T &&) = delete;

int x = 0;
auto array = new int[10];
AddressOf(x); // Ok
AddressOf(array[5]); // Ok
AddressOf(10); // CE: use of deleted function
```

[Конспект-2, стр. 156](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=156).

#### (b) Конструктор перемещения и перемещающее присваивание. Правило пяти.

**Конструктор перемещения и перемещающее присваивание**

Конструктор перемещения и перемещающее присваивание используются для оптимизации работы с временными объектами.

**Пример конструктора перемещения:**

```cpp
class MyClass {
public:
    MyClass(MyClass && other) noexcept {
        // переместить ресурсы из other в this
    }
};
```

**Пример перемещающего присваивания:**

```cpp
MyClass & operator=(MyClass && other) noexcept {
    if (this != &other) {
        // освободить текущие ресурсы
        // переместить ресурсы из other в this
    }
    return *this;
}
```

[Конспект-2, стр. 157](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=157).

**Правило пяти**

Если класс использует динамическое выделение памяти, то необходимо реализовать или запретить пять специальных функций-членов:

1. Конструктор копирования
2. Оператор копирующего присваивания
3. Деструктор
4. Конструктор перемещения
5. Оператор перемещающего присваивания

```cpp
class MyClass {
public:
    MyClass(const MyClass & other); // конструктор копирования
    MyClass & operator=(const MyClass & other); // оператор копирующего присваивания
    ~MyClass(); // деструктор
    MyClass(MyClass && other) noexcept; // конструктор перемещения
    MyClass & operator=(MyClass && other) noexcept; // оператор перемещающего присваивания
};
```

[Конспект-2, стр. 158](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=158).

For more detailed information, please refer to the [document](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf).

# 17. Семантика перемещения

#### (a) Функция `std::move`. Примеры использования.

**Функция `std::move`**

`std::move` не перемещает объект. Она только преобразует аргумент в rvalue-ссылку, позволяя использовать семантику перемещения:

```cpp
#include <utility>
#include <iostream>

int x = 11;
std::move(x); // ничего не произойдет с x
int& rx = std::move(x); // CE: неверная rvalue ссылка
int y = std::move(x); // Ok
int&& rrx = std::move(x); // Ok: правильная rvalue ссылка
rrx = -1; // rrx связан со значением x
std::cout << x << ' ' << rrx; // -1 -1
```

Для базовых типов нет семантики перемещения, поэтому примеры с базовыми типами тривиальны.

**Примеры использования `std::move` со сложными типами:**

```cpp
#include <utility>
#include <iostream>
#include <vector>

std::vector<int> v1 = {1, 2, 3, 4, 5};
std::vector<int> v2 = std::move(v1); // перемещение v1 в v2
```

[Конспект-2, стр. 159](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=159).

#### (b) Функция `std::forward`.

**Функция `std::forward`**

`std::forward` используется для условного перемещения аргумента, если он был принят как rvalue. Это особенно полезно в шаблонных функциях, где тип аргумента может быть как lvalue, так и rvalue:

```cpp
template <class T>
void func(T&& t) {
    other_func(std::forward<T>(t));
}
```

Если `T` является rvalue, `std::forward` переместит `t`. Если `T` является lvalue, `std::forward` не будет перемещать `t`.

```cpp
template <class Func, class Arg>
clock_t RunningTime(Func func, Arg&& arg) {
    const auto start = std::clock();
    func(std::forward<Arg>(arg));
    return std::clock() - start;
}
```

[Конспект-2, стр. 162](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=162).

#### (c) Copy elision. Оптимизация возвращаемого значения (RVO, NRVO).

**Copy elision**

Copy elision — это оптимизация, при которой компилятор может удалить создание и копирование временных объектов. Включает две техники:

- **RVO (Return Value Optimization)** — оптимизация возвращаемого значения.
- **NRVO (Named Return Value Optimization)** — оптимизация именованного возвращаемого значения.

**Пример RVO:**

```cpp
A foo() {
    return A(); // RVO
}
```

**Пример NRVO:**

```cpp
A bar() {
    A a;
    return a; // NRVO
}
```

Компилятор может автоматически оптимизировать эти функции, устраняя ненужное копирование.

[Конспект-2, стр. 162](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=162).

#### (d) Универсальные ссылки (forwarding references). Правила вывода шаблонных параметров для универсальных ссылок. Примеры применения.

**Универсальные ссылки**

Универсальные ссылки (forwarding references) могут быть как lvalue, так и rvalue, в зависимости от контекста:

```cpp
template <typename T>
void func(T&& t) {
    process(std::forward<T>(t));
}
```

**Правила вывода шаблонных параметров**

Шаблонные параметры для универсальных ссылок выводятся так:

- Если передается lvalue, `T` становится lvalue-ссылкой.
- Если передается rvalue, `T` становится rvalue-ссылкой.

**Пример применения:**

```cpp
template <typename T>
void wrapper(T&& arg) {
    func(std::forward<T>(arg));
}

int main() {
    int x = 10;
    wrapper(x); // T deduced as int&
    wrapper(10); // T deduced as int&&
}
```

Это позволяет правильно передавать аргументы в функции, избегая ненужного копирования.

[Конспект-2, стр. 162](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf?pdfPage=162).

For more detailed information, please refer to the [document](https://myaidrive.com/42itGApAqXupcTyveL78By/-2.pdf).
